pipeline {
    agent any

    parameters {
        choice(choices: ['jenkins','main'], name: 'BRANCH_TO_BUILD', description: 'Choix de la branche')
    }

    stages {
        stage('Checkout Code') {
            steps {
                git branch: "${params.BRANCH_TO_BUILD}", url: 'https://github.com/NeoRyu/JDR-Generator'
            }
        }

        stage('Code Quality Checks') {
            environment {
                MAVEN_IMAGE = 'maven:3.8.5-openjdk-17'
                NODE_IMAGE = 'node:20-alpine'
            }
            steps {
                echo '--- Démarrage des vérifications de qualité du code ---'

                // Maven (Java) - Capture de la sortie via fichier temporaire
                script {
                    echo "Exécution des vérifications de qualité de code Maven..."
                    def mavenOutputFilePath = "${WORKSPACE}/maven_output.txt"
                    def mavenScriptPath = "${WORKSPACE}/run_maven_checks.sh"

                    writeFile(file: mavenScriptPath, text: """
                        #!/bin/sh
                        set -eux

                        CONTAINER_ID=\\$(docker create "${MAVEN_IMAGE}" /bin/sh)
                        docker cp "${WORKSPACE}/api/." "\\\$CONTAINER_ID:/app/api/"
                        docker start "\\\$CONTAINER_ID"

                        docker exec "\\\$CONTAINER_ID" /bin/sh -s <<'EOF_MAVEN_CHECK_INNER' > /tmp/maven_output_temp.txt 2>&1
                            set -eux
                            cd /app/api
                            mvn clean verify
                        EOF_MAVEN_CHECK_INNER

                        DOCKER_EXEC_STATUS=\\$?

                        docker cp "\\\$CONTAINER_ID:/tmp/maven_output_temp.txt" "${mavenOutputFilePath}"

                        docker stop "\\\$CONTAINER_ID" || true
                        docker rm "\\\$CONTAINER_ID" || true

                        exit \\\$DOCKER_EXEC_STATUS
                    """.stripIndent())
                    sh "chmod +x ${mavenScriptPath}"

                    try {
                        sh "${mavenScriptPath}"

                        def mavenOutput = readFile(mavenOutputFilePath).trim()
                        echo "--- Sortie des vérifications de qualité de code Maven ---"
                        echo mavenOutput
                        if (mavenOutput.contains("BUILD FAILURE")) {
                            error("Les vérifications de qualité du code Maven ont échoué (BUILD FAILURE détecté dans la sortie).")
                        } else {
                            echo "Les vérifications de qualité du code Maven sont réussies."
                        }
                    } catch (hudson.AbortException e) {
                        def partialOutput = ''
                        if (fileExists(mavenOutputFilePath)) {
                            partialOutput = readFile(mavenOutputFilePath).trim()
                        }
                        echo "--- Sortie partielle des vérifications de qualité du code Maven (en cas d'échec) ---"
                        echo partialOutput
                        error("Les vérifications de qualité du code Maven ont échoué. Détails: ${e.getMessage()}")
                    } finally {
                        sh "rm -f ${mavenOutputFilePath} || true"
                        sh "rm -f ${mavenScriptPath} || true"
                    }
                }

                // Node.js (Web) - npm install
                script {
                    echo "Exécution de 'npm install' pour Node.js (Web)..."
                    def webInstallScriptPath = "${WORKSPACE}/run_web_install.sh"

                    writeFile(file: webInstallScriptPath, text: """
                        #!/bin/sh
                        set -eux

                        CONTAINER_ID=\\$(docker create "${NODE_IMAGE}" /bin/sh)
                        docker cp "${WORKSPACE}/web/." "\\\$CONTAINER_ID:/app/web/"
                        docker start "\\\$CONTAINER_ID"
                        docker exec "\\\$CONTAINER_ID" /bin/sh -s <<'EOF_WEB_INSTALL'
                            set -eux
                            cd /app/web
                            npm install
                        EOF_WEB_INSTALL
                        docker stop "\\\$CONTAINER_ID" || true
                        docker rm "\\\$CONTAINER_ID" || true
                    """.stripIndent())
                    sh "chmod +x ${webInstallScriptPath}"

                    try {
                        sh "${webInstallScriptPath}"
                    } catch (hudson.AbortException e) {
                        error "'npm install' pour Node.js (Web) a échoué. Détails: ${e.getMessage()}"
                    } finally {
                        sh "rm -f ${webInstallScriptPath} || true"
                    }
                }

                // Node.js (Web) - format:check
                script {
                    echo "Exécution de 'format:check' pour Node.js (Web)..."
                    def webFormatOutputFilePath = "${WORKSPACE}/web_format_output.txt"
                    def webFormatScriptPath = "${WORKSPACE}/run_web_format_check.sh"

                    writeFile(file: webFormatScriptPath, text: """
                        #!/bin/sh
                        set -eux

                        CONTAINER_ID=\\$(docker create "${NODE_IMAGE}" /bin/sh)
                        docker cp "${WORKSPACE}/web/." "\\\$CONTAINER_ID:/app/web/"
                        docker start "\\\$CONTAINER_ID"
                        docker exec "\\\$CONTAINER_ID" /bin/sh -s <<'EOF_WEB_FORMAT_INNER' > /tmp/web_format_output_temp.txt 2>&1
                            set -eux
                            cd /app/web
                            npm run format:check
                        EOF_WEB_FORMAT_INNER
                        DOCKER_EXEC_STATUS=\\$?
                        docker cp "\\\$CONTAINER_ID:/tmp/web_format_output_temp.txt" "${webFormatOutputFilePath}"
                        docker stop "\\\$CONTAINER_ID" || true
                        docker rm "\\\$CONTAINER_ID" || true
                        exit \\\$DOCKER_EXEC_STATUS
                    """.stripIndent())
                    sh "chmod +x ${webFormatScriptPath}"

                    try {
                        sh "${webFormatScriptPath}"

                        def webFormatOutput = readFile(webFormatOutputFilePath).trim()
                        echo "--- Sortie de 'format:check' pour Node.js (Web) ---"
                        echo webFormatOutput
                        if (!webFormatOutput.isEmpty()) {
                           echo "Sortie de 'format:check' (si applicable): ${webFormatOutput}"
                        }
                    } catch (hudson.AbortException e) {
                        def partialOutput = ''
                        if (fileExists(webFormatOutputFilePath)) {
                            partialOutput = readFile(webFormatOutputFilePath).trim()
                        }
                        echo "--- Sortie partielle de 'format:check' pour Node.js (Web) (en cas d'échec) ---"
                        echo partialOutput
                        error "'format:check' pour Node.js (Web) a échoué. Détails: ${e.getMessage()}"
                    } finally {
                        sh "rm -f ${webFormatOutputFilePath} || true"
                        sh "rm -f ${webFormatScriptPath} || true"
                    }
                }

                // Node.js (Web) - lint
                script {
                    echo "Exécution de 'lint' pour Node.js (Web)..."
                    def webLintOutputFilePath = "${WORKSPACE}/web_lint_output.txt"
                    def webLintScriptPath = "${WORKSPACE}/run_web_lint.sh"

                    writeFile(file: webLintScriptPath, text: """
                        #!/bin/sh
                        set -eux

                        CONTAINER_ID=\\$(docker create "${NODE_IMAGE}" /bin/sh)
                        docker cp "${WORKSPACE}/web/." "\\\$CONTAINER_ID:/app/web/"
                        docker start "\\\$CONTAINER_ID"
                        docker exec "\\\$CONTAINER_ID" /bin/sh -s <<'EOF_WEB_LINT_INNER' > /tmp/web_lint_output_temp.txt 2>&1
                            set -eux
                            cd /app/web
                            npm run lint
                        EOF_WEB_LINT_INNER
                        DOCKER_EXEC_STATUS=\\$?
                        docker cp "\\\$CONTAINER_ID:/tmp/web_lint_output_temp.txt" "${webLintOutputFilePath}"
                        docker stop "\\\$CONTAINER_ID" || true
                        docker rm "\\\$CONTAINER_ID" || true
                        exit \\\$DOCKER_EXEC_STATUS
                    """.stripIndent())
                    sh "chmod +x ${webLintScriptPath}"

                    try {
                        sh "${webLintScriptPath}"

                        def webLintOutput = readFile(webLintOutputFilePath).trim()
                        echo "--- Sortie de 'lint' pour Node.js (Web) ---"
                        echo webLintOutput
                        if (!webLintOutput.isEmpty()) {
                           echo "Sortie de 'lint' (si applicable): ${webLintOutput}"
                        }
                    } catch (hudson.AbortException e) {
                        def partialOutput = ''
                        if (fileExists(webLintOutputFilePath)) {
                            partialOutput = readFile(webLintOutputFilePath).trim()
                        }
                        echo "--- Sortie partielle de 'lint' pour Node.js (Web) (en cas d'échec) ---"
                        echo partialOutput
                        error "'lint' pour Node.js (Web) a échoué. Détails: ${e.getMessage()}"
                    } finally {
                        sh "rm -f ${webLintOutputFilePath} || true"
                        sh "rm -f ${webLintScriptPath} || true"
                    }
                }

                // Node.js (Gemini) - npm install
                script {
                    echo "Exécution de 'npm install' pour Node.js (Gemini)..."
                    def geminiInstallScriptPath = "${WORKSPACE}/run_gemini_install.sh"

                    writeFile(file: geminiInstallScriptPath, text: """
                        #!/bin/sh
                        set -eux

                        CONTAINER_ID=\\$(docker create "${NODE_IMAGE}" /bin/sh)
                        docker cp "${WORKSPACE}/gemini/." "\\\$CONTAINER_ID:/app/gemini/"
                        docker start "\\\$CONTAINER_ID"
                        docker exec "\\\$CONTAINER_ID" /bin/sh -s <<'EOF_GEMINI_INSTALL'
                            set -eux
                            cd /app/gemini
                            npm install
                        EOF_GEMINI_INSTALL
                        docker stop "\\\$CONTAINER_ID" || true
                        docker rm "\\\$CONTAINER_ID" || true
                    """.stripIndent())
                    sh "chmod +x ${geminiInstallScriptPath}"

                    try {
                        sh "${geminiInstallScriptPath}"
                    } catch (hudson.AbortException e) {
                        error "'npm install' pour Node.js (Gemini) a échoué. Détails: ${e.getMessage()}"
                    } finally {
                        sh "rm -f ${geminiInstallScriptPath} || true"
                    }
                }

                // Node.js (Gemini) - format:check
                script {
                    echo "Exécution de 'format:check' pour Node.js (Gemini)..."
                    def geminiFormatOutputFilePath = "${WORKSPACE}/gemini_format_output.txt"
                    def geminiFormatScriptPath = "${WORKSPACE}/run_gemini_format_check.sh"

                    writeFile(file: geminiFormatScriptPath, text: """
                        #!/bin/sh
                        set -eux

                        CONTAINER_ID=\\$(docker create "${NODE_IMAGE}" /bin/sh)
                        docker cp "${WORKSPACE}/gemini/." "\\\$CONTAINER_ID:/app/gemini/"
                        docker start "\\\$CONTAINER_ID"
                        docker exec "\\\$CONTAINER_ID" /bin/sh -s <<'EOF_GEMINI_FORMAT_INNER' > /tmp/gemini_format_output_temp.txt 2>&1
                            set -eux
                            cd /app/gemini
                            npm run format:check
                        EOF_GEMINI_FORMAT_INNER
                        DOCKER_EXEC_STATUS=\\$?
                        docker cp "\\\$CONTAINER_ID:/tmp/gemini_format_output_temp.txt" "${geminiFormatOutputFilePath}"
                        docker stop "\\\$CONTAINER_ID" || true
                        docker rm "\\\$CONTAINER_ID" || true
                        exit \\\$DOCKER_EXEC_STATUS
                    """.stripIndent())
                    sh "chmod +x ${geminiFormatScriptPath}"

                    try {
                        sh "${geminiFormatScriptPath}"

                        def geminiFormatOutput = readFile(geminiFormatOutputFilePath).trim()
                        echo "--- Sortie de 'format:check' pour Node.js (Gemini) ---"
                        echo geminiFormatOutput
                        if (!geminiFormatOutput.isEmpty()) {
                           echo "Sortie de 'format:check' (si applicable): ${geminiFormatOutput}"
                        }
                    } catch (hudson.AbortException e) {
                        def partialOutput = ''
                        if (fileExists(geminiFormatOutputFilePath)) {
                            partialOutput = readFile(geminiFormatOutputFilePath).trim()
                        }
                        echo "--- Sortie partielle de 'format:check' pour Node.js (Gemini) (en cas d'échec) ---"
                        echo partialOutput
                        error "'format:check' pour Node.js (Gemini) a échoué. Détails: ${e.getMessage()}"
                    } finally {
                        sh "rm -f ${geminiFormatOutputFilePath} || true"
                        sh "rm -f ${geminiFormatScriptPath} || true"
                    }
                }

                // Node.js (Gemini) - lint
                script {
                    echo "Exécution de 'lint' pour Node.js (Gemini)..."
                    def geminiLintOutputFilePath = "${WORKSPACE}/gemini_lint_output.txt"
                    def geminiLintScriptPath = "${WORKSPACE}/run_gemini_lint.sh"

                    writeFile(file: geminiLintScriptPath, text: """
                        #!/bin/sh
                        set -eux

                        CONTAINER_ID=\\$(docker create "${NODE_IMAGE}" /bin/sh)
                        docker cp "${WORKSPACE}/gemini/." "\\\$CONTAINER_ID:/app/gemini/"
                        docker start "\\\$CONTAINER_ID"
                        docker exec "\\\$CONTAINER_ID" /bin/sh -s <<'EOF_GEMINI_LINT_INNER' > /tmp/gemini_lint_output_temp.txt 2>&1
                            set -eux
                            cd /app/gemini
                            npm run lint
                        EOF_GEMINI_LINT_INNER
                        DOCKER_EXEC_STATUS=\\$?
                        docker cp "\\\$CONTAINER_ID:/tmp/gemini_lint_output_temp.txt" "${geminiLintOutputFilePath}"
                        docker stop "\\\$CONTAINER_ID" || true
                        docker rm "\\\$CONTAINER_ID" || true
                        exit \\\$DOCKER_EXEC_STATUS
                    """.stripIndent())
                    sh "chmod +x ${geminiLintScriptPath}"

                    try {
                        sh "${geminiLintScriptPath}"

                        def geminiLintOutput = readFile(geminiLintOutputFilePath).trim()
                        echo "--- Sortie de 'lint' pour Node.js (Gemini) ---"
                        echo geminiLintOutput
                        if (!geminiLintOutput.isEmpty()) {
                           echo "Sortie de 'lint' (si applicable): ${geminiLintOutput}"
                        }
                    } catch (hudson.AbortException e) {
                        def partialOutput = ''
                        if (fileExists(geminiLintOutputFilePath)) {
                            partialOutput = readFile(geminiLintOutputFilePath).trim()
                        }
                        echo "--- Sortie partielle de 'lint' pour Node.js (Gemini) (en cas d'échec) ---"
                        echo partialOutput
                        error "'lint' pour Node.js (Gemini) a échoué. Détails: ${e.getMessage()}"
                    } finally {
                        sh "rm -f ${geminiLintOutputFilePath} || true"
                        sh "rm -f ${geminiLintScriptPath} || true"
                    }
                }

                // Node.js (OpenAI) - npm install
                script {
                    echo "Exécution de 'npm install' pour Node.js (OpenAI)..."
                    def openaiInstallScriptPath = "${WORKSPACE}/run_openai_install.sh"

                    writeFile(file: openaiInstallScriptPath, text: """
                        #!/bin/sh
                        set -eux

                        CONTAINER_ID=\\$(docker create "${NODE_IMAGE}" /bin/sh)
                        docker cp "${WORKSPACE}/openai/." "\\\$CONTAINER_ID:/app/openai/"
                        docker start "\\\$CONTAINER_ID"
                        docker exec "\\\$CONTAINER_ID" /bin/sh -s <<'EOF_OPENAI_INSTALL'
                            set -eux
                            cd /app/openai
                            npm install
                        EOF_OPENAI_INSTALL
                        docker stop "\\\$CONTAINER_ID" || true
                        docker rm "\\\$CONTAINER_ID" || true
                    """.stripIndent())
                    sh "chmod +x ${openaiInstallScriptPath}"

                    try {
                        sh "${openaiInstallScriptPath}"
                    } catch (hudson.AbortException e) {
                        error "'npm install' pour Node.js (OpenAI) a échoué. Détails: ${e.getMessage()}"
                    } finally {
                        sh "rm -f ${openaiInstallScriptPath} || true"
                    }
                }

                // Node.js (OpenAI) - format:check
                script {
                    echo "Exécution de 'format:check' pour Node.js (OpenAI)..."
                    def openaiFormatOutputFilePath = "${WORKSPACE}/openai_format_output.txt"
                    def openaiFormatScriptPath = "${WORKSPACE}/run_openai_format_check.sh"

                    writeFile(file: openaiFormatScriptPath, text: """
                        #!/bin/sh
                        set -eux

                        CONTAINER_ID=\\$(docker create "${NODE_IMAGE}" /bin/sh)
                        docker cp "${WORKSPACE}/openai/." "\\\$CONTAINER_ID:/app/openai/"
                        docker start "\\\$CONTAINER_ID"
                        docker exec "\\\$CONTAINER_ID" /bin/sh -s <<'EOF_OPENAI_FORMAT_INNER' > /tmp/openai_format_output_temp.txt 2>&1
                            set -eux
                            cd /app/openai
                            npm run format:check
                        EOF_OPENAI_FORMAT_INNER
                        DOCKER_EXEC_STATUS=\\$?
                        docker cp "\\\$CONTAINER_ID:/tmp/openai_format_output_temp.txt" "${openaiFormatOutputFilePath}"
                        docker stop "\\\$CONTAINER_ID" || true
                        docker rm "\\\$CONTAINER_ID" || true
                        exit \\\$DOCKER_EXEC_STATUS
                    """.stripIndent())
                    sh "chmod +x ${openaiFormatScriptPath}"

                    try {
                        sh "${openaiFormatScriptPath}"

                        def openaiFormatOutput = readFile(openaiFormatOutputFilePath).trim()
                        echo "--- Sortie de 'format:check' pour Node.js (OpenAI) ---"
                        echo openaiFormatOutput
                        if (!openaiFormatOutput.isEmpty()) {
                           echo "Sortie de 'format:check' (si applicable): ${openaiFormatOutput}"
                        }
                    } catch (hudson.AbortException e) {
                        def partialOutput = ''
                        if (fileExists(openaiFormatOutputFilePath)) {
                            partialOutput = readFile(openaiFormatOutputFilePath).trim()
                        }
                        echo "--- Sortie partielle de 'format:check' pour Node.js (OpenAI) (en cas d'échec) ---"
                        echo partialOutput
                        error "'format:check' pour Node.js (OpenAI) a échoué. Détails: ${e.getMessage()}"
                    } finally {
                        sh "rm -f ${openaiFormatOutputFilePath} || true"
                        sh "rm -f ${openaiFormatScriptPath} || true"
                    }
                }

                // Node.js (OpenAI) - lint
                script {
                    echo "Exécution de 'lint' pour Node.js (OpenAI)..."
                    def openaiLintOutputFilePath = "${WORKSPACE}/openai_lint_output.txt"
                    def openaiLintScriptPath = "${WORKSPACE}/run_openai_lint.sh"

                    writeFile(file: openaiLintScriptPath, text: """
                        #!/bin/sh
                        set -eux

                        CONTAINER_ID=\\$(docker create "${NODE_IMAGE}" /bin/sh)
                        docker cp "${WORKSPACE}/openai/." "\\\$CONTAINER_ID:/app/openai/"
                        docker start "\\\$CONTAINER_ID"
                        docker exec "\\\$CONTAINER_ID" /bin/sh -s <<'EOF_OPENAI_LINT_INNER' > /tmp/openai_lint_output_temp.txt 2>&1
                            set -eux
                            cd /app/openai
                            npm run lint
                        EOF_OPENAI_LINT_INNER
                        DOCKER_EXEC_STATUS=\\$?
                        docker cp "\\\$CONTAINER_ID:/tmp/openai_lint_output_temp.txt" "${openaiLintOutputFilePath}"
                        docker stop "\\\$CONTAINER_ID" || true
                        docker rm "\\\$CONTAINER_ID" || true
                        exit \\\$DOCKER_EXEC_STATUS
                    """.stripIndent())
                    sh "chmod +x ${openaiLintScriptPath}"

                    try {
                        sh "${openaiLintScriptPath}"

                        def openaiLintOutput = readFile(openaiLintOutputFilePath).trim()
                        echo "--- Sortie de 'lint' pour Node.js (OpenAI) ---"
                        echo openaiLintOutput
                        if (!openaiLintOutput.isEmpty()) {
                           echo "Sortie de 'lint' (si applicable): ${openaiLintOutput}"
                        }
                    } catch (hudson.AbortException e) {
                        def partialOutput = ''
                        if (fileExists(openaiLintOutputFilePath)) {
                            partialOutput = readFile(openaiLintOutputFilePath).trim()
                        }
                        echo "--- Sortie partielle de 'lint' pour Node.js (OpenAI) (en cas d'échec) ---"
                        echo partialOutput
                        error "'lint' pour Node.js (OpenAI) a échoué. Détails: ${e.getMessage()}"
                    } finally {
                        sh "rm -f ${openaiLintOutputFilePath} || true"
                        sh "rm -f ${openaiLintScriptPath} || true"
                    }
                }
            }

            post {
                always {
                    echo "Nettoyage des fichiers temporaires et des conteneurs Docker..."
                }
                failure {
                    echo "Des vérifications de qualité du code ont échouées !"
                }
                success {
                    echo "Toutes les vérifications de qualité du code ont réussies !"
                }
            }
        }
    }
}